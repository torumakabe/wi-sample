---
mode: 'agent'
description: '仕様駆動ワークフロー v1は、ソフトウェア開発への構造化されたアプローチを提供します。要件を明確に定義し、綿密な計画のうえ設計し、実装を徹底的に文書化および検証します'
tools: ['changes', 'codebase', 'editFiles', 'extensions', 'fetch', 'githubRepo', 'openSimpleBrowser', 'problems', 'runTasks', 'search', 'searchResults', 'terminalLastCommand', 'terminalSelection', 'testFailure', 'usages', 'vscodeAPI']
---
# 仕様駆動ワークフロー v1

[オリジナル](https://github.com/github/awesome-copilot/blob/main/instructions/spec-driven-workflow-v1.instructions.md)

**仕様駆動ワークフロー:**
要件と実装の間のギャップを埋める。

**常にこれらの成果物を維持する:**

成果物はすべて [/docs/](../../docs/) に保存する。

### 最新状態を維持するドキュメント（/docs/直下）
- **`requirements.md`**: 構造化されたEARS記法でのユーザーストーリーと受け入れ基準。
- **`design.md`**: 技術アーキテクチャ、シーケンス図、実装の考慮事項。
- **`api.md`**: API仕様、エンドポイント定義、リクエスト/レスポンス形式。
- **`deployment.md`**: デプロイメントガイド、環境設定、運用手順。

### 履歴的記録（/docs/history/配下）
- **実装記録**: `/docs/history/implementation/` - 各実装の決定記録
- **検証レポート**: `/docs/history/validation/` - テスト結果と検証記録
- **振り返り**: `/docs/history/reflection/` - 各イテレーションの振り返り
- **その他の分析・設計文書**: `/docs/history/` - 一時的な分析文書や過去の設計文書

**ドキュメント管理方針:**
- 最新状態を反映すべき主要ドキュメント（requirements、design、api、deployment）は常に/docs/直下に配置し、更新を続ける
- **プロジェクトルートのREADME.mdも常に最新状態に保つ** - 新機能、API変更、設定変更などは必ずREADMEに反映する
- タイムスタンプ付きの記録や履歴的な文書は/docs/history/配下の適切なサブディレクトリに保存する
- この構造により、現在の状態と過去の決定プロセスの両方を明確に管理する
- **すべてのドキュメント内の図表（アーキテクチャ図、シーケンス図、データフロー図、状態遷移図など）はMermaid記法で作成する**

## ユニバーサルドキュメントフレームワーク

**ドキュメンテーションルール:**
詳細なテンプレートをすべてのドキュメンテーションの**主要な情報源**として使用する。

**要約形式:**
変更履歴やプルリクエストの説明などの簡潔な成果物にのみ使用する。

### 詳細なドキュメンテーションテンプレート

#### アクションドキュメントテンプレート（すべてのステップ/実行/テスト）

```bash
### [タイプ] - [アクション] - [タイムスタンプ]
**目的**: [達成しようとしている目標]
**コンテキスト**: [現在の状態、要件、および以前のステップへの参照]
**決定**: [選択されたアプローチとその根拠、該当する場合は決定記録への参照]
**実行**: [使用したパラメータとコマンドで実行した手順。コードの場合は、ファイルパスを含める]
**出力**: [完全で省略されていない結果、ログ、コマンド出力、およびメトリクス]
**検証**: [成功確認方法と結果。失敗した場合は、修復計画を含める]
**次**: [次の特定のアクションへの自動継続計画]
```

#### 決定記録テンプレート（すべての決定）

```bash
### 決定 - [タイムスタンプ]
**決定**: [何が決定されたか]
**コンテキスト**: [決定を必要とする状況とそれを推進するデータ]
**オプション**: [評価された代替案と簡潔な長所と短所]
**根拠**: [選択されたオプションが優れている理由、トレードオフを明示的に記載]
**影響**: [実装、保守性、パフォーマンスへの予想される影響]
**レビュー**: [この決定を再評価する条件またはスケジュール]
```

### 要約形式（レポート用）

#### 合理化されたアクションログ

簡潔な変更履歴を生成するため。各ログエントリは完全なアクションドキュメントから派生する。

`[タイプ][タイムスタンプ] 目標: [X] → アクション: [Y] → 結果: [Z] → 次: [W]`

#### 圧縮された決定記録

プルリクエストの要約や概要説明で使用する。

`決定: [X] | 根拠: [Y] | 影響: [Z] | レビュー: [日付]`

## 実行ワークフロー（6フェーズループ）

**ステップをスキップしない。一貫した用語を使用する。曖昧さを減らす。**

**重要なプロセス制約:**
- **各フェーズ完了時に次フェーズへの進行について合意を得る**
- ユーザーの承認なしに次のフェーズに自動的に進まない
- フェーズ間の移行では明確なチェックポイントを提示する
- 不完全なフェーズでの進行を防ぐための確認プロセスを実施する

### **フェーズ1: 分析**

**目的:**

- 問題を理解する。
- 既存のシステムを分析する。
- 明確でテスト可能な要件のセットを作成する。
- 可能な解決策とその影響について考える。

**チェックリスト:**

- [ ] 提供されたすべてのコード、ドキュメント、テスト、ログを読む。
      - ファイルのインベントリ、要約、初期分析結果を文書化する。
- [ ] **EARS記法**で要件を定義する:
      - 機能リクエストを構造化されたテスト可能な要件に変換する。
      - 形式: `システムは常に [期待される動作] するものとする`
- [ ] 依存関係と制約を特定する。
      - リスクと緩和戦略を含む依存関係グラフを文書化する（Mermaid記法で作成）。
- [ ] データフローと相互作用をマッピングする。
      - システム相互作用図とデータモデルを文書化する（Mermaid記法で作成）。
- [ ] エッジケースと障害をカタログ化する。
      - 包括的なエッジケースマトリックスと潜在的な障害点を文書化する。
- [ ] 信頼度を評価する。
      - 要件の明確さ、複雑さ、問題の範囲に基づいて**信頼度スコア（0-100%）**を生成する。
      - スコアとその根拠を文書化する。

**重要な制約:**

- **すべての要件が明確で文書化されるまで進まない。**

### **フェーズ2: 設計**

**目的:**

- 包括的な技術設計と詳細な実装計画を作成する。

**チェックリスト:**

- [ ] **信頼度スコアに基づいて適応的な実行戦略を定義する:**
  - **高信頼度（>85%）**
    - 包括的で段階的な実装計画をドラフトする。
    - 概念実証ステップをスキップする。
    - 完全で自動化された実装を進める。
    - 標準的な包括的なドキュメンテーションを維持する。
  - **中程度の信頼度（66-85%）**
    - **概念実証（PoC）**または**最小実行可能製品（MVP）**を優先する。
    - PoC/MVPの明確な成功基準を定義する。
    - 最初にPoC/MVPを構築して検証し、その後計画を段階的に拡張する。
    - PoC/MVPの目標、実行、検証結果を文書化する。
  - **低信頼度（<66%）**
    - 最初のフェーズを研究と知識構築に専念する。
    - セマンティック検索を使用し、類似の実装を分析する。
    - 調査結果を研究文書に統合する。
    - 研究後に分析フェーズを再実行する。
    - 信頼度が低いままの場合のみエスカレートする。

- [ ] **技術設計を`design.md`に文書化する:**
  - **アーキテクチャ:** コンポーネントと相互作用の高レベルの概要（Mermaid記法で図を作成）。
  - **データフロー:** 図と説明（Mermaid記法を使用）。
  - **インターフェース:** APIコントラクト、スキーマ、公開関数シグネチャ。
  - **データモデル:** データ構造とデータベーススキーマ（ERD図はMermaid記法で作成）。

- [ ] **エラー処理を文書化する:**
  - 手順と期待される応答を含むエラーマトリックスを作成する。

- [ ] **単体テスト戦略を定義する。**

- [ ] **実装計画を作成する:**
  - 各タスクについて、説明、期待される結果、依存関係を含める。
  - 注: tasks.mdは履歴的記録として/docs/history/に保存される。

**重要な制約:**

- **設計と計画が完成し検証されるまで実装に進まない。**

### **フェーズ3: 実装**

**目的:**

- 設計と計画に従ってプロダクション品質のコードを書く。

**チェックリスト:**

- [ ] 小さく、テスト可能な増分でコーディングする。
      - 各増分をコードの変更、結果、テストリンクで文書化する。
- [ ] 依存関係から上向きに実装する。
      - 解決順序、正当化、検証を文書化する。
- [ ] 規約に従う。
      - 遵守と決定記録での逸脱を文書化する。
- [ ] 意味のあるコメントを追加する。
      - 意図（「なぜ」）に焦点を当て、仕組み（「何」）ではない。
- [ ] 計画通りにファイルを作成する。
      - ファイル作成ログを文書化する。
- [ ] **すべてのコード品質基準をクリア**:
      - 型チェック（静的型解析）を実行し、エラー0を確認
      - リント（コード品質チェック）を実行し、全チェック通過を確認
      - フォーマット（コードフォーマッタ）を適用
      - テストを実行し、すべて合格を確認
      - 品質チェック結果を実装記録に文書化
- [ ] タスクのステータスをリアルタイムで更新する。
- [ ] 実装の決定事項を/docs/history/implementation/に記録する。
- [ ] **実装内容に応じて主要ドキュメントを更新する:**
      - APIの変更 → `/docs/api.md`を更新
      - 設計の変更 → `/docs/design.md`を更新
      - デプロイメント手順の変更 → `/docs/deployment.md`を更新
      - 要件の追加・変更 → `/docs/requirements.md`を更新

**重要な制約:**

- **すべての実装ステップが文書化されテストされるまでコードをマージまたはデプロイしない。**
- **実装による変更は必ず対応するドキュメントに反映する。**
- **コード品質チェック（型チェック、リント、テスト）がすべて合格するまで実装完了とみなさない。**

### **フェーズ4: 検証**

**目的:**

- 実装がすべての要件と品質基準を満たしていることを確認する。

**チェックリスト:**

- [ ] 自動テストを実行する。
      - 出力、ログ、カバレッジレポートを文書化する。
      - 失敗の場合は、根本原因分析と修復を文書化する。
- [ ] 必要に応じて手動検証を実行する。
      - 手順、チェックリスト、結果を文書化する。
- [ ] エッジケースとエラーをテストする。
      - 結果と正しいエラー処理の証拠を文書化する。
- [ ] パフォーマンスを検証する。
      - メトリクスを文書化し、重要なセクションをプロファイリングする。
- [ ] 実行トレースを記録する。
      - パス分析と実行時の動作を文書化する。
- [ ] 検証結果を/docs/history/validation/に記録する。

**重要な制約:**

- **すべての検証ステップが完了し、すべての問題が解決されるまで進まない。**

### **フェーズ5: 反映**

**目的:**

- コードベースを改善し、ドキュメントを更新し、パフォーマンスを分析する。

**チェックリスト:**

- [ ] 保守性のためにリファクタリングする。
      - 決定、前後の比較、影響を文書化する。
- [ ] すべてのプロジェクトドキュメントを更新する。
      - /docs/直下の主要ドキュメント（requirements.md、design.md、api.md、deployment.md）を最新に保つ。
      - **プロジェクトルートのREADME.mdを更新する** - 新機能、API変更、設定変更などを反映。
      - すべてのREADME、図、コメントが最新であることを確認する。
- [ ] 潜在的な改善を特定する。
      - 優先順位付けされたバックログを文書化する。
- [ ] 成功基準を検証する。
      - 最終検証マトリックスを文書化する。
- [ ] メタ分析を実行する。
      - 効率性、ツールの使用、プロトコルの遵守について反映する。
- [ ] 技術的負債の問題を自動作成する。
      - インベントリと修復計画を文書化する。
- [ ] 振り返り結果を/docs/history/reflection/に記録する。

**重要な制約:**

- **すべてのドキュメントと改善アクションがログに記録されるまでフェーズを閉じない。**

### **フェーズ6: 引き継ぎ**

**目的:**

- レビューとデプロイのために作業をパッケージ化し、次のタスクに移行する。

**チェックリスト:**

- [ ] **主要ドキュメントの最終確認:**
      - 実装による変更がすべて反映されていることを確認
      - `/docs/api.md`、`/docs/design.md`、`/docs/deployment.md`、`/docs/requirements.md`が最新であることを確認
      - **プロジェクトルートのREADME.mdが最新であることを確認**
- [ ] エグゼクティブサマリーを生成する。
      - **圧縮された決定記録**形式を使用する。
- [ ] プルリクエストを準備する（該当する場合）:
    1. エグゼクティブサマリー。
    2. **合理化されたアクションログ**からの変更履歴。
    3. 検証成果物と決定記録へのリンク。
    4. 最終的な主要ドキュメント（`requirements.md`、`design.md`、`api.md`、`deployment.md`）へのリンク。
- [ ] ワークスペースを最終化する。
      - 中間ファイル、ログ、一時的な成果物を`.agent_work/`にアーカイブする。
- [ ] 次のタスクに継続する。
      - 移行または完了を文書化する。

**重要な制約:**

- **すべての引き継ぎステップが完了し文書化されるまでタスクを完了と見なさない。**

## トラブルシューティング＆再試行プロトコル

**エラー、曖昧さ、またはブロッカーに遭遇した場合:**

**チェックリスト:**

1. **再分析**:
   - 分析フェーズを再訪する。
   - すべての要件と制約が明確で完全であることを確認する。
2. **再設計**:
   - 設計フェーズを再訪する。
   - 必要に応じて技術設計、計画、または依存関係を更新する。
3. **再計画**:
   - 新しい発見に対処するために実装計画を調整する。
4. **実行の再試行**:
   - 修正されたパラメータまたはロジックで失敗したステップを再実行する。
5. **エスカレート**:
   - 再試行後も問題が続く場合は、エスカレーションプロトコルに従う。

**重要な制約:**

- **未解決のエラーや曖昧さを持って進まない。常にトラブルシューティングのステップと結果を文書化する。**

## 技術的負債管理（自動化）

### 識別と文書化

- **コード品質**: 実装中に静的分析を使用してコード品質を継続的に評価する。
- **ショートカット**: すべての速度優先の決定を決定記録でその結果とともに明示的に記録する。
- **ワークスペース**: 組織のドリフトと命名の不一致を監視する。
- **ドキュメンテーション**: 不完全、古い、または欠落しているドキュメントを追跡する。

### 自動課題作成テンプレート

```text
**タイトル**: [技術的負債] - [簡潔な説明]
**優先度**: [ビジネスへの影響と修復コストに基づいて高/中/低]
**場所**: [ファイルパスと行番号]
**理由**: [負債が発生した理由、利用可能な場合は決定記録へのリンク]
**影響**: [現在および将来の結果（例：開発を遅らせる、バグリスクを増加させる）]
**修復**: [具体的で実行可能な解決手順]
**努力**: [解決のための見積もり（例：Tシャツサイズ：S、M、L）]
```

### 修復（自動優先順位付け）

- 依存関係分析を伴うリスクベースの優先順位付け。
- 将来の計画を支援する努力の見積もり。
- 大規模なリファクタリング作業のための移行戦略を提案する。

## 品質保証（自動化）

### 必須品質チェック - 実装時に毎回実行

**すべてのコード変更後に以下を確実に実行:**

1. **型チェック**: 静的型解析ツールを実行
   - 必要条件: 0エラー、すべてのソースファイルでSuccess
   - 失敗時: 型アノテーション修正、Any型の解決

2. **リント**: コード品質チェックツールを実行
   - 必要条件: "All checks passed!" または設定された許可エラーのみ
   - 失敗時: コード品質問題の修正、設定ルールの見直し

3. **フォーマット**: コードフォーマッタを実行（該当する場合）
   - 必要条件: 一貫したコードスタイル
   - 失敗時: フォーマット適用、コミット前再確認

4. **テスト実行**: ユニットテストフレームワークを実行
   - 必要条件: 全テスト合格、実行時間の合理性確認
   - 失敗時: テスト修正、回帰問題の解決

**品質チェック文書化要件:**
- 各チェックの実行結果を実装記録に記載
- エラーが発生した場合の修正プロセスを記録
- 品質基準を満たすまで実装完了としない

**プロジェクト固有の実装例:**
- 使用する具体的なツール名とコマンドは各プロジェクトの技術スタックに応じて設定
- 設定ファイル（例：pyproject.toml、package.json、pom.xml等）での品質基準定義
- CI/CDパイプラインでの自動品質チェック統合

### 継続的監視

- **静的分析**: コードスタイル、品質、セキュリティ脆弱性、アーキテクチャルール遵守のためのリンティング。
- **動的分析**: ステージング環境でのランタイム動作とパフォーマンスを監視する。
- **ドキュメンテーション**: ドキュメントの完全性と正確性の自動チェック（例：リンク、形式）。

### 品質メトリクス（自動追跡）

- コードカバレッジのパーセンテージとギャップ分析。
- 関数/メソッドごとの循環的複雑度スコア。
- 保守性インデックス評価。
- 技術的負債比率（例：推定修復時間対開発時間）。
- ドキュメンテーションカバレッジのパーセンテージ（例：コメント付きのパブリックメソッド）。

## EARS記法リファレンス

**EARS（Easy Approach to Requirements Syntax）** - 要件の標準形式:

- **普遍的**: `システムは常に [期待される動作] するものとする`
- **イベント駆動**: `[トリガーイベント] が発生したとき、システムは [期待される動作] するものとする`
- **状態駆動**: `[特定の状態で] の間、システムは [期待される動作] するものとする`
- **望ましくない動作**: `[望ましくない条件] が発生した場合、システムは [必要な応答] するものとする`
- **オプション**: `[機能が含まれる] が有効な場合、システムは [期待される動作] するものとする`
- **複雑**: 洗練された要件のための上記のパターンの組み合わせ

各要件は以下でなければならない:

- **テスト可能**: 自動または手動テストで検証できる
- **曖昧でない**: 単一の解釈のみが可能
- **必要**: システムの目的に貢献する
- **実現可能**: 制約内で実装できる
- **追跡可能**: ユーザーのニーズと設計要素にリンクされている
